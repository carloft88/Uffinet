trigger: none

pool:
  vmImage: 'windows-latest'

variables:
  DB_NAME: 'db-datahub-pro-01'
  SQL_CONNECTION_STRING: 'Server=sql-ironhub-pro-01.database.windows.net,1433;Database=$(DB_NAME);User ID=usuario;Password=$(SQL_PASSWORD);Encrypt=yes;TrustServerCertificate=no;Connection Timeout=30;'
  OUTPUT_FOLDER: 'artifacts'         # (no se usa; se mantiene por compatibilidad)
  OUTPUT_FILE: 'tablas_temp_tmp.csv' # (no se usa; se mantiene por compatibilidad)
  MAIL_TO: 'ccastrillonc@Ufinet.com' # separados por coma si hay varios
  MAIL_FROM: 'ccastrillonc@Ufinet.com'
  MAIL_SUBJECT: 'Reporte tablas TEMP/TMP - $(DB_NAME)'

steps:
- task: PowerShell@2
  displayName: 'Preparar entorno (instalar módulo SqlServer)'
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      $ProgressPreference = 'SilentlyContinue'
      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

      $mod = Get-Module -ListAvailable SqlServer | Sort-Object Version -Descending | Select-Object -First 1
      if (-not $mod) {
        Write-Host "Instalando módulo SqlServer..."
        Install-Module SqlServer -Scope CurrentUser -Force -AllowClobber
      } else {
        Write-Host "Módulo SqlServer ya disponible: $($mod.Version)"
      }

- task: PowerShell@2
  displayName: 'Query SQL (SQL Auth) y construir HTML (cuerpo de correo)'
  env:
    SQL_PASSWORD: $(SQL_PASSWORD)      # secreta
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'
      Import-Module SqlServer -ErrorAction Stop

      # --- Parsear la cadena de conexión ---
      $conn = "$(SQL_CONNECTION_STRING)"
      if ([string]::IsNullOrWhiteSpace($conn)) { throw "SQL_CONNECTION_STRING está vacío." }

      $map = @{}
      foreach ($part in $conn.Split(';')) {
        if ($part -match '=') {
          $kv = $part.Split('=')
          $k = $kv[0].Trim().ToLowerInvariant()
          $v = ($kv[1..($kv.Length-1)] -join '=').Trim()
          if ($k) { $map[$k] = $v }
        }
      }

      $server   = $map['server']
      $database = $map['database']
      $username = $map['user id']
      if ([string]::IsNullOrWhiteSpace($server))   { throw "No se pudo leer 'Server' de SQL_CONNECTION_STRING." }
      if ([string]::IsNullOrWhiteSpace($database)) { $database = "$(DB_NAME)" }
      if ([string]::IsNullOrWhiteSpace($username)) { throw "No se pudo leer 'User ID' de SQL_CONNECTION_STRING." }

      $password = $env:SQL_PASSWORD
      if ([string]::IsNullOrWhiteSpace($password)) { throw "La variable secreta SQL_PASSWORD no está definida." }

      # --- Query (here-string con comilla simple, delimitadores al inicio de línea) ---
@'
SET NOCOUNT ON;
SELECT
    s.name AS schema_name,
    t.name AS table_name,
    SUM(p.rows) AS row_count
FROM sys.tables t
JOIN sys.schemas s ON t.schema_id = s.schema_id
LEFT JOIN sys.partitions p
       ON p.object_id = t.object_id
      AND p.index_id IN (0,1)
WHERE t.is_ms_shipped = 0
  AND (t.name LIKE ''%temp%'' OR t.name LIKE ''%tmp%'')
GROUP BY s.name, t.name
ORDER BY row_count DESC, s.name, t.name;
'@ | Out-File -FilePath "$env:Agent_TempDirectory\query.sql" -Encoding UTF8

      $query = Get-Content "$env:Agent_TempDirectory\query.sql" -Raw -Encoding UTF8

      $rows = Invoke-Sqlcmd -ServerInstance $server -Database $database -Username $username -Password $password -Query $query -ErrorAction Stop

      # Métricas
      $totalTablas = 0
      $totalFilas  = 0
      if ($rows) {
        $totalTablas = ($rows | Measure-Object).Count
        $totalFilas  = (($rows | Measure-Object -Sum row_count).Sum)
      }

      if (-not $rows -or $rows.Count -eq 0) {
        $rows = @([pscustomobject]@{ schema_name = '(sin coincidencias)'; table_name=''; row_count=0 })
      }

      # --- HTML (here-string con comilla simple; tags reales, no escapados) ---
@'
<style>
  body { font-family: Segoe UI, Arial, sans-serif; color:#222; }
  h2 { margin: 0 0 8px 0; }
  .meta { font-size:12px; color:#555; margin-bottom:12px; }
  table { border-collapse: collapse; width: 100%; }
  th, td { border: 1px solid #ddd; padding: 6px 8px; font-size: 13px; }
  th { background:#f2f2f2; text-align:left; }
  tr:nth-child(even) { background:#fafafa; }
</style>
'@ | Out-File -FilePath "$env:Agent_TempDirectory\style.html" -Encoding UTF8

      $style = Get-Content "$env:Agent_TempDirectory\style.html" -Raw -Encoding UTF8

      $header = "<h2>Reporte de tablas 'temp'/'tmp' - $database</h2>"
      $meta   = "<div class='meta'>Generado: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz')<br/>Servidor: $server<br/>Total tablas: $totalTablas<br/>Total filas (suma): $totalFilas</div>"

      $table = $rows | Select-Object schema_name, table_name, row_count | ConvertTo-Html -Fragment | Out-String

      $htmlBody = "<html><head>$style</head><body>$header$meta$table</body></html>"

      $env:HTML_BODY_PATH = "$(Agent.TempDirectory)\mail_body.html"
      Set-Content -Path $env:HTML_BODY_PATH -Value $htmlBody -Encoding UTF8
      Write-Host "##vso[task.setvariable variable=HTML_BODY_PATH;isOutput=true]$($env:HTML_BODY_PATH)"
      Write-Host "HTML listo en $($env:HTML_BODY_PATH)"

- task: PowerShell@2
  displayName: 'Enviar correo (SendGrid) – cuerpo HTML'
  env:
    SENDGRID_API_KEY: $(SENDGRID_API_KEY)  # secreta
  inputs:
    targetType: 'inline'
    script: |
      $ErrorActionPreference = 'Stop'

      $htmlPath = "$(HTML_BODY_PATH)"
      if (-not (Test-Path $htmlPath)) {
        throw "No se encontró el cuerpo HTML en $htmlPath"
      }
      $htmlBody = Get-Content -Path $htmlPath -Raw -Encoding UTF8

      $toList = @()
      foreach ($addr in "$(MAIL_TO)".Split(',')) {
        $trim = $addr.Trim()
        if ($trim) { $toList += @{ email = $trim } }
      }
      if ($toList.Count -eq 0) { throw "MAIL_TO está vacío." }

      $payload = @{
        personalizations = @(@{ to = $toList; subject = "$(MAIL_SUBJECT)" })
        from = @{ email = "$(MAIL_FROM)" }
        content = @(@{ type = "text/html"; value = $htmlBody })
      } | ConvertTo-Json -Depth 10

      $headers = @{
        "Authorization" = "Bearer $env:SENDGRID_API_KEY"
        "Content-Type"  = "application/json"
      }

      Invoke-RestMethod -Method Post -Uri "https://api.sendgrid.com/v3/mail/send" -Headers $headers -Body $payload
      Write-Host "Correo enviado (HTML en el cuerpo)."